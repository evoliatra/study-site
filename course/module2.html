<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Класс Tk и методы виджетов.</title>
    <link rel="stylesheet" href="D:/site/css/style2.css">
</head>
<body>
	<header>
		<nav>
			<ul id="list_menu">
				<li><a href="D:/site/index.html">Главная</a></li>
				<li><a href="D:/site/index.html#course">Уроки</a></li>
				<li><a href="D:/site/doc.html">Документация</a></li>
			</ul>
		</nav>
        <div class="text"> 
		<h1>Класс Tk и методы виджетов.</h1>
	    <h3>Tk является базовым классом любого Tkinter приложения. При создании объекта этого класса запускается интерпретатор tcl/tk и создаётся базовое окно приложения. Здесь мы узнаем основные команды, которые понадобятся нам при создании своего приложения.</h3>
        </div>
    </header>
	<main>
		<h3>Разделы модуля</h3>
        <hr>
        <div class="razdel">
		    <ol>
			    <li><a href="#cltk">Класс Tk</a></li>
			    <li><a href="#ob">Общее для всех виджетов</a></li>
			    <li><a href="#metod">Методы виджетов</a></li>
			    <li><a href="#sysmetod">Системные методы</a></li>
			    <li><a href="#test2">Тест</a></li>
			</ol>
        </div>
        <h4><a name="cltk">Класс Tk</a></h4>
        <hr>
        <p>Tk является базовым классом любого Tkinter приложения. При создании объекта этого класса запускается интерпретатор tcl/tk и создаётся базовое окно приложения.</p>
        <p>Tkinter является событийно-ориентированной библиотекой. В приложениях такого типа имеется главный цикл обработки событий. В Tkinter такой цикл запускается методом mainloop. Для явного выхода из интерпретатора и завершения цикла обработки событий используется метод quit.</p>
        <p>Таким образом минимальное приложение на Tkinter будет таким:</p>
        <pre>
        <code>
            from tkinter import *
            root = Tk()
            root.mainloop()
        </code>
        </pre>
        <p>В приложении можно использовать несколько интерпретаторов tcl/tk. Так как после вызова метода mainloop дальнейшие команды python исполняться не будут до выхода из цикла обработки событий, необходимо метод mainloop всех интерпретаторов кроме последнего осуществлять в фоновом режиме.</p>
        <p><em>Пример запуска двух интерпретаторов:</em></p>
        <pre>
        <code>
            from tkinter import *
            root1 = Tk()
            root2 = Tk()
            root1.after(500, root1.mainloop) # первый цикл запускаем в фоне
            root2.mainloop()
        </code>
        </pre>
        <p>При использовании двух и более интерпретаторов необходимо следить, чтобы объекты, созданные в одном интерпретаторе, использовались только в нём. Например, изображение, созданное в первом интерпретаторе, может быть использовано много раз в этом же интерпретаторе, но не может быть использовано в других интерпретаторах. Необходимость в запуске нескольких интерпретаторов в одном приложении возникает крайне редко. Для создания дополнительного окна приложения в большинстве случаев достаточно виджета Toplevel.</p>
        <h4><a name="ob">Общее для всех виджетов</a></h4>
        <hr>
        <p>Все виджеты в Tkinter обладают некоторыми общими свойствами.</p>
        <p>Виджеты создаются вызовом конструктора соответствующего класса. Первый аргумент (как правило неименованный, но можно использовать имя master) это родительский виджет, в который будет упакован (помещён) наш виджет. Родительский виджет можно не указывать, в таком случае будет использовано главное окно приложения.</p>
        <p>Далее следуют именованные аргументы, конфигурирующие виджет. Это может быть используемый шрифт (font=...), цвет виджета (bg=...), команда, выполняющаяся при активации виджета (command=...) и т.д.</p>
        <p>Полный список всех аргументов можно посмотреть в man options и man-странице соответствующего виджета.</p>
        <p><em>Пример кода:</em></p>
        <pre>
        <code>
            from tkinter import *
            def button_clicked():
            print ("Клик!")
            root=Tk()
            # кнопка по умолчанию
            button1 = Button()
            button1.pack()
            # кнопка с указанием родительского виджета и несколькими аргументами
            button2 = Button(root, bg="red", text=u"Кликни меня!", command=button_clicked)
            button2.pack()
            root.mainloop()
        </code>
        </pre>
        <h4><a name="metod">Методы виджетов</a></h4>
        <hr>
        <p><b>Метод configure, config</b></p>
        <p>Виджеты могут быть сконфигурированы во время создания, но иногда необходимо изменить конфигурацию виджета во время исполнения программы. Для этого используется метод <strong>configure</strong> (или его синоним <strong>config</strong>). Также можно использовать квадратные скобки (widget['option'] = new_value). Пример, программа выводит текущее время, после клика по кнопке:</p>
        <pre>
        <code>
            from tkinter import *
            import time
            def button_clicked():
            # изменяем текст кнопки
            button['text'] = time.strftime('%H:%M:%S')
            root=Tk()
            # создаём виджет
            button = Button(root)
            # конфигурируем виджет после создания
            button.configure(text=time.strftime('%H:%M:%S'), command=button_clicked)
            # также можно использовать квадратные скобки:
            # button['text'] = time.strftime('%H:%M:%S')
            # button['command'] = button_clicked
            button.pack()
            root.mainloop()
        </code>
        </pre>
        <p>В этом коде функция <strong>button_clicked</strong> вызывается каждый раз, когда пользователь кликает по кнопке.</p>
        <h4><a name="sysmetod">Системные методы</a></h4> <hr>
        <p>Эти методы не являются виджет-специфичными, т.е. хотя они являются методами виджетов они влияют на работу интерпретатора tcl/tk.</p>
        <p><b>Методы after, after_idle и after_cancel</b></p>
        <p>Таймеры. С помощью этих методов вы можете отложить выполнение какого-нибудь кода на определённое время.</p>
        <p><strong>after</strong> - принимает два аргумента: время в миллисекундах и функцию, которую надо выполнить через указанное время. Возвращает идентификатор, который может быть использован в after_cancel.</p>
        <p><strong>after_idle</strong> - принимает один аргумент - функцию. Эта функция будет выполнена после завершения всех отложенных операций (после того, как будут обработаны все события). Возвращает идентификатор, который может быть использован в after_cancel.</p>
        <p><strong>after_cancel</strong> - принимает один аргумент: идентификатор задачи, полученный предыдущими функциями, и отменяет это задание.</p>
        <p><em>Пример, часы:</em></p>
        <pre>
        <code>
            from Tkinter import *
            import time
            def tick():
            label.after(200, tick)
            label['text'] = time.strftime('%H:%M:%S')
            root=Tk()
            label = Label(font='sans 20')
            label.pack()
            label.after_idle(tick)
            root.mainloop()
        </code>
        </pre>
        <p><b>Методы update и update_idletasks.</b></p>
        <p>Две функции, для работы с очередью задач. Их выполнение вызывает обработку отложенных задач.</p>
        <p><strong>update_idletasks</strong> выполняет задачи, обычно откладываемые "на потом", когда приложение будет простаивать. Это приводит к прорисовке всех виджетов, расчёту их расположения и т.д. Обычно эта функция используется если были внесены изменения в состояние приложения, и вы хотите, чтобы эти изменения были отображены на экране немедленно, не дожидаясь завершения сценария.</p>
        <p><strong>update</strong> обрабатывает все задачи, стоящие в очереди. Обычно эта функция используется во время "тяжёлых" расчётов, когда необходимо чтобы приложение оставалось отзывчивым на действия пользователя.</p>
        <p><em>Пример:</em></p>
        <pre>
        <code>
            from Tkinter import *
            import math
            def hard_job():
            x = 1000
            while True:
            x = math.log(x) ** 2.8
            root.update()
            root=Tk()
            button = Button()
            button.pack()
            root.after(500, hard_job)
            root.mainloop()
        </code>
        </pre>
        <p><b>Методы eval и evalfile</b></p>
        <p>Две недокументированные функции для выполнения кода на tcl. eval позволяет выполнить строку на языке программирования tcl, а evalfile - выполнить код, записанный в файл. В качестве аргументов принимают соответственно строку и путь к файлу. Данные функции полезны при использовании дополнительных модулей, написанных на tcl.</p> 
        <p><em>Пример:</em></p>
        <pre>
        <code>
            from Tkinter import *
            root=Tk()
            root.eval('package require tile; ttk::style theme use clam')
            root.eval('ttk::button .b -text {ttk button}; pack .b')
            root.mainloop()
        </code>
        </pre>
        <h4><a name="test2">Тест</a></h4>
        <hr>
        <div class="wrapper">
            <iframe src="D:/site/quiz/q3.html" width="480" height="720" class="quiz-frame"></iframe>
        </div>
        <div class="btn-up btn-up_hide"><script src="D:/site/js/butup.js"></script></div>
	</main>
	<footer>
        <h3>Программирование GUI на Python</h3>
        <h4>Курс по созданию графических интерфейсов с помощью библиотеки Tkinter.</h4>
        <p>Воронежский государственный педагогический университет</p><p>&#169;Михайлова Мария, 2023</p>
        <p><a href="mailto:mkhlvmari@gmail.com">mkhlvmari@gmail.com</a></p>
    </footer>
</body>
</html>